"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
exports.__esModule = true;
/**
 * Sigma.js WebGL Renderer
 * ========================
 *
 * File implementing sigma's WebGL Renderer.
 */
var extent_1 = require("graphology-metrics/extent");
var is_graph_1 = require("graphology-utils/is-graph");
var renderer_1 = require("../../renderer");
var camera_1 = require("../../camera");
var mouse_1 = require("../../captors/mouse");
var quadtree_1 = require("../../quadtree");
var display_data_1 = require("../display-data");
var utils_1 = require("../../utils");
var utils_2 = require("../utils");
var utils_3 = require("./utils");
var labels_1 = require("../../heuristics/labels");
var z_index_1 = require("../../heuristics/z-index");
var settings_1 = require("./settings");
var nodeExtent = extent_1["default"].nodeExtent, edgeExtent = extent_1["default"].edgeExtent;
/**
 * Constants.
 */
var PIXEL_RATIO = utils_2.getPixelRatio();
var WEBGL_OVERSAMPLING_RATIO = utils_2.getPixelRatio();
/**
 * Main class.
 *
 * @constructor
 * @param {Graph}       graph     - Graph to render.
 * @param {HTMLElement} container - DOM container in which to render.
 * @param {object}      settings  - Optional settings.
 */
var WebGLRenderer = /** @class */ (function (_super) {
    __extends(WebGLRenderer, _super);
    function WebGLRenderer(graph, container, settings) {
        if (settings === void 0) { settings = {}; }
        var _this = _super.call(this) || this;
        _this.captors = {};
        _this.elements = {};
        _this.contexts = {};
        _this.listeners = {};
        _this.quadtree = new quadtree_1["default"]();
        _this.nodeDataCache = {};
        _this.edgeDataCache = {};
        _this.nodeExtent = null;
        _this.edgeExtent = null;
        _this.normalizationFunction = null;
        // Starting dimensions
        _this.width = 0;
        _this.height = 0;
        // State
        _this.highlightedNodes = new Set();
        _this.displayedLabels = new Set();
        _this.hoveredNode = null;
        _this.wasRenderedInThisFrame = false;
        _this.renderFrame = null;
        _this.renderHighlightedNodesFrame = null;
        _this.needToProcess = false;
        _this.needToSoftProcess = false;
        // programs
        _this.nodePrograms = {};
        _this.edgePrograms = {};
        _this.settings = utils_1.assign({}, settings_1.WEBGL_RENDERER_DEFAULT_SETTINGS, settings);
        settings_1.validateWebglRendererSettings(_this.settings);
        // Validating
        if (!is_graph_1["default"](graph))
            throw new Error("sigma/renderers/webgl: invalid graph instance.");
        if (!(container instanceof HTMLElement))
            throw new Error("sigma/renderers/webgl: container should be an html element.");
        // Properties
        _this.graph = graph;
        _this.container = container;
        _this.initializeCache();
        // Initializing contexts
        _this.createContext("edges");
        _this.createContext("edgeLabels", false);
        _this.createContext("nodes");
        _this.createContext("labels", false);
        _this.createContext("hovers", false);
        _this.createContext("mouse", false);
        // Blending
        var gl = _this.contexts.nodes;
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);
        gl = _this.contexts.edges;
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);
        // Loading programs
        for (var type in _this.settings.nodeProgramClasses) {
            var NodeProgramClass = _this.settings.nodeProgramClasses[type];
            _this.nodePrograms[type] = new NodeProgramClass(_this.contexts.nodes);
        }
        for (var type in _this.settings.edgeProgramClasses) {
            var EdgeProgramClass = _this.settings.edgeProgramClasses[type];
            _this.edgePrograms[type] = new EdgeProgramClass(_this.contexts.edges);
        }
        // Initial resize
        _this.resize();
        // Initializing the camera
        _this.camera = new camera_1["default"]();
        // Binding camera events
        _this.bindCameraHandlers();
        // Initializing captors
        _this.captors = {
            mouse: new mouse_1["default"](_this.elements.mouse, _this.camera)
        };
        // Binding event handlers
        _this.bindEventHandlers();
        // Binding graph handlers
        _this.bindGraphHandlers();
        // Processing data for the first time & render
        _this.process();
        _this.render();
        return _this;
    }
    /**---------------------------------------------------------------------------
     * Internal methods.
     **---------------------------------------------------------------------------
     */
    /**
     * Internal function used to create a canvas context and add the relevant
     * DOM elements.
     *
     * @param  {string}  id    - Context's id.
     * @param  {boolean} webgl - Whether the context is a webgl or canvas one.
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.createContext = function (id, webgl) {
        if (webgl === void 0) { webgl = true; }
        var element = utils_2.createElement("canvas", {
            "class": "sigma-" + id,
            style: {
                position: "absolute"
            }
        });
        this.elements[id] = element;
        this.container.appendChild(element);
        var contextOptions = {
            preserveDrawingBuffer: false,
            antialias: false
        };
        var context;
        if (webgl) {
            // First we try webgl2 for an easy performance boost
            context = element.getContext("webgl2", contextOptions);
            // Else we fall back to webgl
            if (!context)
                context = element.getContext("webgl", contextOptions);
            // Edge, I am looking right at you...
            if (!context)
                context = element.getContext("experimental-webgl", contextOptions);
        }
        else {
            context = element.getContext("2d", contextOptions);
        }
        this.contexts[id] = context;
        return this;
    };
    /**
     * Method used to initialize display data cache.
     *
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.initializeCache = function () {
        var graph = this.graph;
        var nodes = graph.nodes();
        for (var i = 0, l = nodes.length; i < l; i++)
            this.nodeDataCache[nodes[i]] = new display_data_1.NodeDisplayData(i, this.settings);
        var edges = graph.edges();
        for (var i = 0, l = edges.length; i < l; i++)
            this.edgeDataCache[edges[i]] = new display_data_1.EdgeDisplayData(i, this.settings);
    };
    /**
     * Method binding camera handlers.
     *
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.bindCameraHandlers = function () {
        var _this = this;
        this.listeners.camera = function () {
            _this.scheduleRender();
        };
        this.camera.on("updated", this.listeners.camera);
        return this;
    };
    /**
     * Method binding event handlers.
     *
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.bindEventHandlers = function () {
        var _this = this;
        // Handling window resize
        this.listeners.handleResize = function () {
            _this.needToSoftProcess = true;
            _this.scheduleRender();
        };
        window.addEventListener("resize", this.listeners.handleResize);
        // Function checking if the mouse is on the given node
        var mouseIsOnNode = function (mouseX, mouseY, nodeX, nodeY, size) {
            return (mouseX > nodeX - size &&
                mouseX < nodeX + size &&
                mouseY > nodeY - size &&
                mouseY < nodeY + size &&
                Math.sqrt(Math.pow(mouseX - nodeX, 2) + Math.pow(mouseY - nodeY, 2)) < size);
        };
        // Function returning the nodes in the mouse's quad
        var getQuadNodes = function (mouseX, mouseY) {
            var mouseGraphPosition = _this.camera.viewportToGraph(_this, mouseX, mouseY);
            // TODO: minus 1? lol
            return _this.quadtree.point(mouseGraphPosition.x, 1 - mouseGraphPosition.y);
        };
        // Handling mouse move
        this.listeners.handleMove = function (e) {
            // NOTE: for the canvas renderer, testing the pixel's alpha should
            // give some boost but this slows things down for WebGL empirically.
            // TODO: this should be a method from the camera (or can be passed to graph to display somehow)
            var sizeRatio = Math.pow(_this.camera.getState().ratio, 0.5);
            var quadNodes = getQuadNodes(e.x, e.y);
            // We will hover the node whose center is closest to mouse
            var minDistance = Infinity, nodeToHover = null;
            for (var i = 0, l = quadNodes.length; i < l; i++) {
                var node = quadNodes[i];
                var data = _this.nodeDataCache[node];
                var pos = _this.camera.graphToViewport(_this, data.x, data.y);
                var size = data.size / sizeRatio;
                if (mouseIsOnNode(e.x, e.y, pos.x, pos.y, size)) {
                    var distance = Math.sqrt(Math.pow(e.x - pos.x, 2) + Math.pow(e.y - pos.y, 2));
                    // TODO: sort by min size also for cases where center is the same
                    if (distance < minDistance) {
                        minDistance = distance;
                        nodeToHover = node;
                    }
                }
            }
            if (nodeToHover && _this.hoveredNode !== nodeToHover) {
                // Handling passing from one node to the other directly
                if (_this.hoveredNode !== null)
                    _this.emit("leaveNode", { node: _this.hoveredNode });
                _this.hoveredNode = nodeToHover;
                _this.emit("enterNode", { node: nodeToHover });
                return _this.scheduleHighlightedNodesRender();
            }
            // Checking if the hovered node is still hovered
            if (_this.hoveredNode) {
                var data = _this.nodeDataCache[_this.hoveredNode];
                var pos = _this.camera.graphToViewport(_this, data.x, data.y);
                var size = data.size / sizeRatio;
                if (!mouseIsOnNode(e.x, e.y, pos.x, pos.y, size)) {
                    var node = _this.hoveredNode;
                    _this.hoveredNode = null;
                    _this.emit("leaveNode", { node: node });
                    return _this.scheduleHighlightedNodesRender();
                }
            }
        };
        // Handling click
        var createClickListener = function (eventType) {
            return function (e) {
                var sizeRatio = Math.pow(_this.camera.getState().ratio, 0.5);
                var quadNodes = getQuadNodes(e.x, e.y);
                for (var i = 0, l = quadNodes.length; i < l; i++) {
                    var node = quadNodes[i];
                    var data = _this.nodeDataCache[node];
                    var pos = _this.camera.graphToViewport(_this, data.x, data.y);
                    var size = data.size / sizeRatio;
                    if (mouseIsOnNode(e.x, e.y, pos.x, pos.y, size))
                        return _this.emit(eventType + "Node", { node: node, captor: e, event: e });
                }
                return _this.emit(eventType + "Stage", { event: e });
            };
        };
        this.listeners.handleClick = createClickListener("click");
        this.listeners.handleRightClick = createClickListener("rightClick");
        this.listeners.handleDown = createClickListener("down");
        this.captors.mouse.on("mousemove", this.listeners.handleMove);
        this.captors.mouse.on("click", this.listeners.handleClick);
        this.captors.mouse.on("rightClick", this.listeners.handleRightClick);
        this.captors.mouse.on("mousedown", this.listeners.handleDown);
        return this;
    };
    /**
     * Method binding graph handlers
     *
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.bindGraphHandlers = function () {
        var _this = this;
        var graph = this.graph;
        this.listeners.graphUpdate = function () {
            _this.needToProcess = true;
            _this.scheduleRender();
        };
        this.listeners.softGraphUpdate = function () {
            _this.needToSoftProcess = true;
            _this.scheduleRender();
        };
        this.listeners.addNodeGraphUpdate = function (e) {
            // Adding entry to cache
            _this.nodeDataCache[e.key] = new display_data_1.NodeDisplayData(graph.order - 1, _this.settings);
            _this.listeners.graphUpdate();
        };
        this.listeners.addEdgeGraphUpdate = function (e) {
            // Adding entry to cache
            _this.edgeDataCache[e.key] = new display_data_1.EdgeDisplayData(graph.size - 1, _this.settings);
            _this.listeners.graphUpdate();
        };
        // TODO: clean cache on drop!
        // TODO: bind this on composed state events
        // TODO: it could be possible to update only specific node etc. by holding
        // a fixed-size pool of updated items
        graph.on("nodeAdded", this.listeners.addNodeGraphUpdate);
        graph.on("nodeDropped", this.listeners.graphUpdate);
        graph.on("nodeAttributesUpdated", this.listeners.softGraphUpdate);
        graph.on("edgeAdded", this.listeners.addEdgeGraphUpdate);
        graph.on("nodeDropped", this.listeners.graphUpdate);
        graph.on("edgeAttributesUpdated", this.listeners.softGraphUpdate);
        graph.on("cleared", this.listeners.graphUpdate);
        return this;
    };
    /**
     * Method used to process the whole graph's data.
     *
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.process = function (keepArrays) {
        if (keepArrays === void 0) { keepArrays = false; }
        var graph = this.graph, settings = this.settings;
        // Clearing the quad
        this.quadtree.clear();
        // Computing extents
        var nodeExtentProperties = ["x", "y"];
        if (this.settings.zIndex) {
            nodeExtentProperties.push("z");
            this.edgeExtent = edgeExtent(graph, ["z"]);
        }
        this.nodeExtent = nodeExtent(graph, nodeExtentProperties);
        // Rescaling function
        this.normalizationFunction = utils_2.createNormalizationFunction(this.nodeExtent);
        var nodeProgram = this.nodePrograms[this.settings.defaultNodeType];
        if (!keepArrays)
            nodeProgram.allocate(graph.order);
        var nodes = graph.nodes();
        // Handling node z-index
        // TODO: z-index needs us to compute display data before hand
        // TODO: remains to be seen if reducers are a good or bad thing and if we
        // should store display data in flat byte arrays indices
        if (this.settings.zIndex)
            nodes = z_index_1.zIndexOrdering(this.edgeExtent.z, function (node) { return graph.getNodeAttribute(node, "z"); }, nodes);
        for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            var data = graph.getNodeAttributes(node);
            var displayData = this.nodeDataCache[node];
            if (settings.nodeReducer)
                data = settings.nodeReducer(node, data);
            // TODO: should assign default also somewhere here if there is a reducer
            displayData.assign(data);
            this.normalizationFunction.applyTo(displayData);
            this.quadtree.add(node, displayData.x, 1 - displayData.y, displayData.size / this.width);
            nodeProgram.process(displayData, i);
            displayData.index = i;
        }
        nodeProgram.bufferData();
        var edgeProgram = this.edgePrograms[this.settings.defaultEdgeType];
        if (!keepArrays)
            edgeProgram.allocate(graph.size);
        var edges = graph.edges();
        // Handling edge z-index
        if (this.settings.zIndex)
            edges = z_index_1.zIndexOrdering(this.edgeExtent.z, function (edge) { return graph.getEdgeAttribute(edge, "z"); }, edges);
        for (var i = 0, l = edges.length; i < l; i++) {
            var edge = edges[i];
            var data = graph.getEdgeAttributes(edge);
            var displayData = this.edgeDataCache[edge];
            if (settings.edgeReducer)
                data = settings.edgeReducer(edge, data);
            displayData.assign(data);
            var extremities = graph.extremities(edge), sourceData = this.nodeDataCache[extremities[0]], targetData = this.nodeDataCache[extremities[1]];
            edgeProgram.process(sourceData, targetData, displayData, i);
            displayData.index = i;
        }
        // Computing edge indices if necessary
        if (!keepArrays && typeof edgeProgram.computeIndices === "function")
            edgeProgram.computeIndices();
        edgeProgram.bufferData();
        return this;
    };
    /**
     * Method used to process a single node.
     *
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.processNode = function (key) {
        var nodeProgram = this.nodePrograms[this.settings.defaultNodeType];
        var data = this.graph.getNodeAttributes(key);
        nodeProgram.process(data, this.nodeDataCache[key].index);
        return this;
    };
    /**
     * Method used to process a single edge.
     *
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.processEdge = function (key) {
        var graph = this.graph;
        var edgeProgram = this.edgePrograms[this.settings.defaultEdgeType];
        var data = graph.getEdgeAttributes(key), extremities = graph.extremities(key), sourceData = graph.getNodeAttributes(extremities[0]), targetData = graph.getNodeAttributes(extremities[1]);
        edgeProgram.process(sourceData, targetData, data, this.edgeDataCache[key].index);
        return this;
    };
    /**---------------------------------------------------------------------------
     * Public API.
     **---------------------------------------------------------------------------
     */
    /**
     * Method returning the renderer's camera.
     *
     * @return {Camera}
     */
    WebGLRenderer.prototype.getCamera = function () {
        return this.camera;
    };
    /**
     * Method returning the mouse captor.
     *
     * @return {Camera}
     */
    WebGLRenderer.prototype.getMouseCaptor = function () {
        return this.captors.mouse;
    };
    /**
     * Method used to resize the renderer.
     *
     * @param  {number} width  - Target width.
     * @param  {number} height - Target height.
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.resize = function (width, height) {
        var previousWidth = this.width, previousHeight = this.height;
        if (arguments.length > 1) {
            this.width = width;
            this.height = height;
        }
        else {
            this.width = this.container.offsetWidth;
            this.height = this.container.offsetHeight;
        }
        if (this.width === 0)
            throw new Error("sigma/renderers/webgl: container has no width.");
        if (this.height === 0)
            throw new Error("sigma/renderers/webgl: container has no height.");
        // If nothing has changed, we can stop right here
        if (previousWidth === this.width && previousHeight === this.height)
            return this;
        // Sizing dom elements
        for (var id in this.elements) {
            var element = this.elements[id];
            element.style.width = this.width + "px";
            element.style.height = this.height + "px";
        }
        // Sizing contexts
        for (var id in this.contexts) {
            var context_1 = this.contexts[id];
            // Canvas contexts
            if (context_1.scale) {
                this.elements[id].setAttribute("width", this.width * PIXEL_RATIO + "px");
                this.elements[id].setAttribute("height", this.height * PIXEL_RATIO + "px");
                if (PIXEL_RATIO !== 1)
                    context_1.scale(PIXEL_RATIO, PIXEL_RATIO);
            }
            // WebGL contexts
            else {
                this.elements[id].setAttribute("width", this.width * WEBGL_OVERSAMPLING_RATIO + "px");
                this.elements[id].setAttribute("height", this.height * WEBGL_OVERSAMPLING_RATIO + "px");
            }
            if (context_1.viewport) {
                context_1.viewport(0, 0, this.width * WEBGL_OVERSAMPLING_RATIO, this.height * WEBGL_OVERSAMPLING_RATIO);
            }
        }
        return this;
    };
    /**
     * Method used to clear the canvases.
     *
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.clear = function () {
        this.contexts.nodes.clear(this.contexts.nodes.COLOR_BUFFER_BIT);
        this.contexts.edges.clear(this.contexts.edges.COLOR_BUFFER_BIT);
        this.contexts.labels.clearRect(0, 0, this.width, this.height);
        this.contexts.hovers.clearRect(0, 0, this.width, this.height);
        this.contexts.edgeLabels.clearRect(0, 0, this.width, this.height);
        return this;
    };
    /**
     * Method used to render.
     *
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.render = function () {
        // If a render was scheduled, we cancel it
        if (this.renderFrame) {
            cancelAnimationFrame(this.renderFrame);
            this.renderFrame = null;
            this.needToProcess = false;
            this.needToSoftProcess = false;
        }
        // First we need to resize
        this.resize();
        // Clearing the canvases
        this.clear();
        // If we have no nodes we can stop right there
        if (!this.graph.order)
            return this;
        // TODO: improve this heuristic or move to the captor itself?
        var moving = this.camera.isAnimated() ||
            this.captors.mouse.isMoving ||
            this.captors.mouse.hasDragged ||
            this.captors.mouse.wheelLock;
        // Then we need to extract a matrix from the camera
        var cameraState = this.camera.getState(), cameraMatrix = utils_3.matrixFromCamera(cameraState, {
            width: this.width,
            height: this.height
        });
        var program;
        // Drawing nodes
        program = this.nodePrograms[this.settings.defaultNodeType];
        program.render({
            matrix: cameraMatrix,
            width: this.width,
            height: this.height,
            ratio: cameraState.ratio,
            nodesPowRatio: 0.5,
            scalingRatio: WEBGL_OVERSAMPLING_RATIO
        });
        // Drawing edges
        if (!this.settings.hideEdgesOnMove || !moving) {
            program = this.edgePrograms[this.settings.defaultEdgeType];
            program.render({
                matrix: cameraMatrix,
                width: this.width,
                height: this.height,
                ratio: cameraState.ratio,
                nodesPowRatio: 0.5,
                edgesPowRatio: 0.5,
                scalingRatio: WEBGL_OVERSAMPLING_RATIO
            });
        }
        // Do not display labels on move per setting
        if (this.settings.hideLabelsOnMove && moving)
            return this;
        this.renderLabels();
        this.renderEdgeLabels();
        this.renderHighlightedNodes();
        return this;
    };
    /**
     * Method used to render labels.
     *
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.renderLabels = function () {
        if (!this.settings.renderLabels)
            return this;
        var cameraState = this.camera.getState();
        // Finding visible nodes to display their labels
        var visibleNodes;
        if (cameraState.ratio >= 1) {
            // Camera is unzoomed so no need to ask the quadtree for visible nodes
            visibleNodes = this.graph.nodes();
        }
        else {
            // Let's ask the quadtree
            var viewRectangle = this.camera.viewRectangle(this);
            visibleNodes = this.quadtree.rectangle(viewRectangle.x1, 1 - viewRectangle.y1, viewRectangle.x2, 1 - viewRectangle.y2, viewRectangle.height);
        }
        // Selecting labels to draw
        var gridSettings = this.settings.labelGrid;
        var labelsToDisplay = labels_1.labelsToDisplayFromGrid({
            cache: this.nodeDataCache,
            camera: this.camera,
            cell: gridSettings.cell,
            dimensions: this,
            displayedLabels: this.displayedLabels,
            fontSize: this.settings.labelSize,
            graph: this.graph,
            renderedSizeThreshold: gridSettings.renderedSizeThreshold,
            visibleNodes: visibleNodes
        });
        // Drawing labels
        var context = this.contexts.labels;
        var sizeRatio = Math.pow(cameraState.ratio, 0.5);
        for (var i = 0, l = labelsToDisplay.length; i < l; i++) {
            var data = this.nodeDataCache[labelsToDisplay[i]];
            var _a = this.camera.graphToViewport(this, data.x, data.y), x = _a.x, y = _a.y;
            // TODO: we can cache the labels we need to render until the camera's ratio changes
            // TODO: this should be computed in the canvas components?
            var size = data.size / sizeRatio;
            this.settings.labelRenderer(context, {
                key: labelsToDisplay[i],
                label: data.label,
                size: size,
                x: x,
                y: y
            }, this.settings);
        }
        // Caching visible nodes and displayed labels
        this.displayedLabels = new Set(labelsToDisplay);
        return this;
    };
    /**
     * Method used to render edge labels, based on which node labels were
     * rendered.
     *
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.renderEdgeLabels = function () {
        if (!this.settings.renderEdgeLabels)
            return this;
        var cameraState = this.camera.getState();
        var sizeRatio = Math.pow(cameraState.ratio, 0.5);
        var context = this.contexts.edgeLabels;
        // Clearing
        context.clearRect(0, 0, this.width, this.height);
        var edgeLabelsToDisplay = labels_1.edgeLabelsToDisplayFromNodes({
            graph: this.graph,
            hoveredNode: this.hoveredNode,
            displayedNodeLabels: this.displayedLabels,
            highlightedNodes: this.highlightedNodes
        });
        for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {
            var edge = edgeLabelsToDisplay[i], extremities = this.graph.extremities(edge), sourceData = this.nodeDataCache[extremities[0]], targetData = this.nodeDataCache[extremities[1]], edgeData = this.edgeDataCache[edgeLabelsToDisplay[i]];
            var _a = this.camera.graphToViewport(this, sourceData.x, sourceData.y), sourceX = _a.x, sourceY = _a.y;
            var _b = this.camera.graphToViewport(this, targetData.x, targetData.y), targetX = _b.x, targetY = _b.y;
            // TODO: we can cache the labels we need to render until the camera's ratio changes
            // TODO: this should be computed in the canvas components?
            var size = edgeData.size / sizeRatio;
            this.settings.edgeLabelRenderer(context, {
                key: edge,
                label: edgeData.label,
                color: edgeData.color,
                size: size
            }, {
                key: extremities[0],
                x: sourceX,
                y: sourceY
            }, {
                key: extremities[1],
                x: targetX,
                y: targetY
            }, this.settings);
        }
        return this;
    };
    /**
     * Method used to render the highlighted nodes.
     *
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.renderHighlightedNodes = function () {
        var _this = this;
        var camera = this.camera;
        var sizeRatio = Math.pow(camera.getState().ratio, 0.5);
        var context = this.contexts.hovers;
        // Clearing
        context.clearRect(0, 0, this.width, this.height);
        // Rendering
        var render = function (node) {
            var data = _this.nodeDataCache[node];
            var _a = camera.graphToViewport(_this, data.x, data.y), x = _a.x, y = _a.y;
            var size = data.size / sizeRatio;
            _this.settings.hoverRenderer(context, {
                key: node,
                label: data.label,
                color: data.color,
                size: size,
                x: x,
                y: y
            }, _this.settings);
        };
        if (this.hoveredNode)
            render(this.hoveredNode);
        this.highlightedNodes.forEach(render);
    };
    /**
     * Method used to schedule a render.
     *
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.scheduleRender = function () {
        var _this = this;
        // A frame is already scheduled
        if (this.renderFrame)
            return this;
        // Let's schedule a frame
        this.renderFrame = requestAnimationFrame(function () {
            // Do we need to process data?
            if (_this.needToProcess) {
                _this.process();
            }
            else if (_this.needToSoftProcess) {
                _this.process(true);
            }
            // Resetting state
            _this.renderFrame = null;
            _this.needToProcess = false;
            _this.needToSoftProcess = false;
            // Rendering
            _this.render();
        });
    };
    /**
     * Method used to schedule a hover render.
     *
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.scheduleHighlightedNodesRender = function () {
        var _this = this;
        if (this.renderHighlightedNodesFrame || this.renderFrame)
            return this;
        this.renderHighlightedNodesFrame = requestAnimationFrame(function () {
            // Resetting state
            _this.renderHighlightedNodesFrame = null;
            // Rendering
            _this.renderHighlightedNodes();
            _this.renderEdgeLabels();
        });
    };
    /**
     * Method used to manually refresh.
     *
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.refresh = function () {
        this.needToSoftProcess = true;
        this.scheduleRender();
        return this;
    };
    /**
     * Method used to highlight a node.
     *
     * @param  {string} key - The node's key.
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.highlightNode = function (key) {
        // TODO: check the existence of the node
        // TODO: coerce?
        this.highlightedNodes.add(key);
        // Rendering
        this.scheduleHighlightedNodesRender();
        return this;
    };
    /**
     * Method used to unhighlight a node.
     *
     * @param  {string} key - The node's key.
     * @return {WebGLRenderer}
     */
    WebGLRenderer.prototype.unhighlightNode = function (key) {
        // TODO: check the existence of the node
        // TODO: coerce?
        this.highlightedNodes["delete"](key);
        // Rendering
        this.scheduleHighlightedNodesRender();
        return this;
    };
    /**
     * Method used to shut the container & release event listeners.
     *
     * @return {undefined}
     */
    WebGLRenderer.prototype.kill = function () {
        var graph = this.graph;
        // Emitting "kill" events so that plugins and such can cleanup
        this.emit("kill");
        // Releasing events
        this.removeAllListeners();
        // Releasing camera handlers
        this.camera.removeListener("updated", this.listeners.camera);
        // Releasing DOM events & captors
        window.removeEventListener("resize", this.listeners.handleResize);
        this.captors.mouse.kill();
        // Releasing graph handlers
        graph.removeListener("nodeAdded", this.listeners.addNodeGraphUpdate);
        graph.removeListener("nodeDropped", this.listeners.graphUpdate);
        graph.removeListener("nodeAttributesUpdated", this.listeners.softGraphUpdate);
        graph.removeListener("edgeAdded", this.listeners.addEdgeGraphUpdate);
        graph.removeListener("nodeDropped", this.listeners.graphUpdate);
        graph.removeListener("edgeAttributesUpdated", this.listeners.softGraphUpdate);
        graph.removeListener("cleared", this.listeners.graphUpdate);
        // Releasing cache & state
        this.quadtree = null;
        this.nodeDataCache = null;
        this.edgeDataCache = null;
        this.highlightedNodes = null;
        this.displayedLabels = null;
        // Clearing frames
        if (this.renderFrame) {
            cancelAnimationFrame(this.renderFrame);
            this.renderFrame = null;
        }
        if (this.renderHighlightedNodesFrame) {
            cancelAnimationFrame(this.renderHighlightedNodesFrame);
            this.renderHighlightedNodesFrame = null;
        }
        // Destroying canvases
        var container = this.container;
        while (container.firstChild)
            container.removeChild(container.firstChild);
    };
    return WebGLRenderer;
}(renderer_1["default"]));
exports["default"] = WebGLRenderer;
