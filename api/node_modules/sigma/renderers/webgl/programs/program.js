"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCompoundProgram = void 0;
/**
 * Sigma.js WebGL Renderer Program
 * ================================
 *
 * Class representing a single WebGL program used by sigma's WebGL renderer.
 */
var utils_1 = require("../shaders/utils");
/**
 * Program class.
 *
 * @constructor
 */
var Program = /** @class */ (function () {
    function Program(gl, vertexShaderSource, fragmentShaderSource) {
        this.array = null;
        // Binding context
        this.gl = gl;
        this.vertexShaderSource = vertexShaderSource;
        this.fragmentShaderSource = fragmentShaderSource;
        this.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        this.load(gl);
    }
    /**
     * Method used to load the program into a webgl context.
     *
     * @param  {WebGLContext} gl - The WebGL context.
     * @return {WebGLProgram}
     */
    Program.prototype.load = function (gl) {
        this.vertexShader = utils_1.loadVertexShader(gl, this.vertexShaderSource);
        this.fragmentShader = utils_1.loadFragmentShader(gl, this.fragmentShaderSource);
        this.program = utils_1.loadProgram(gl, [this.vertexShader, this.fragmentShader]);
        return this.program;
    };
    return Program;
}());
exports.default = Program;
/**
 * Helper function combining two or more programs into a single compound one.
 * Note that this is more a quick & easy way to combine program than a really
 * performant option. More performant programs can be written entirely.
 *
 * @param  {array}    programClasses - Program classes to combine.
 * @return {function}
 */
// TODO: maybe those should handle their own canvases
function createCompoundProgram(programClasses) {
    return /** @class */ (function () {
        function CompoundProgram(gl) {
            this.programs = programClasses.map(function (ProgramClass) { return new ProgramClass(gl); });
        }
        CompoundProgram.prototype.allocate = function (capacity) {
            this.programs.forEach(function (program) { return program.allocate(capacity); });
        };
        CompoundProgram.prototype.process = function () {
            var args = arguments;
            this.programs.forEach(function (program) { return program.process.apply(program, __spread(args)); });
        };
        CompoundProgram.prototype.computeIndices = function () {
            this.programs.forEach(function (program) {
                if (typeof program.computeIndices === "function")
                    program.computeIndices();
            });
        };
        CompoundProgram.prototype.bufferData = function () {
            this.programs.forEach(function (program) { return program.bufferData(); });
        };
        CompoundProgram.prototype.render = function () {
            var args = arguments;
            this.programs.forEach(function (program) {
                program.bind();
                program.bufferData();
                program.render.apply(program, __spread(args));
            });
        };
        return CompoundProgram;
    }());
}
exports.createCompoundProgram = createCompoundProgram;
